{"ast":null,"code":"export async function calcTrades(inputData) {\n  // inputData = this.props.slic;\n  if (inputData[0].side == \"Buy\" && inputData[0].execType == \"Trade\") {\n    let avgBuyPrice = 0;\n    let avgSellPrice = 0;\n    let totBuyContracts = 0;\n    let totSellContracts = 0;\n    let buyNum = 0;\n    let sellNum = 0;\n    let totBuyContractsMult = 0;\n    let totSellContractsMult = 0;\n    let realQty = 0;\n    let totCommission = 0;\n\n    for (let i = 0; i < inputData.length; i++) {\n      // realQty = inputData[i].orderQty - inputData[i].leavesQty;\n      if (inputData[i].side == \"Buy\" && inputData[i].leavesQty == 0) {\n        buyNum += 1;\n        totBuyContracts += inputData[i].orderQty;\n        totBuyContractsMult += inputData[i].orderQty * parseFloat(inputData[i].price);\n      }\n\n      if (inputData[i].side == \"Sell\" && inputData[i].leavesQty == 0) {\n        sellNum += 1;\n        totSellContracts += inputData[i].orderQty;\n        totSellContractsMult += inputData[i].orderQty * parseFloat(inputData[i].price);\n      }\n\n      if (inputData[i].orderType == \"Limit\" && inputData[i].execType !== \"Funding\") {\n        totCommission += realQty * 0.0025 / inputData[i].price;\n      }\n\n      if (inputData[i].orderType == \"Market\") {\n        totCommission -= realQty * 0.0075 / inputData[i].price;\n      }\n\n      if (inputData[i].orderType.includes(\"Stop\")) {\n        totCommission -= realQty * 0.0075 / inputData[i].price;\n      }\n\n      if (i == inputData.length - 1) {\n        avgBuyPrice = totBuyContractsMult / totBuyContracts;\n        avgSellPrice = totSellContractsMult / totSellContracts;\n        let avgExit;\n        let avgEntry;\n\n        if (avgBuyPrice != null) {\n          avgEntry = avgBuyPrice;\n        } else {\n          avgEntry = 0;\n        }\n\n        if (avgSellPrice != null) {\n          avgExit = avgSellPrice;\n        } else {\n          avgExit = 0;\n        } // this.state.cumQty = totBuyContracts;\n\n\n        let thePnl = (1 / avgBuyPrice - 1 / avgSellPrice) * totSellContracts;\n\n        if (thePnl != null) {\n          let myPnl = thePnl + totCommission;\n          return new Promise(resolve => {\n            let end = {};\n            end[\"pnl\"] = myPnl;\n            end[\"avgEntryPrice\"] = avgEntry;\n            end[\"avgExitPrice\"] = avgExit;\n            end[\"cumQty\"] = totBuyContracts;\n            resolve(end);\n          }); //   store.addPnl(myPnl);\n        } else {\n          return new Promise(resolve => {\n            let end = {};\n            end[\"pnl\"] = 0;\n            end[\"avgEntryPrice\"] = avgEntry;\n            end[\"avgExitPrice\"] = avgExit;\n            end[\"cumQty\"] = totBuyContracts;\n            resolve(end);\n          });\n        }\n      }\n    }\n  }\n\n  if (inputData[0].side == \"Sell\" && inputData[0].execType == \"Trade\") {\n    let totBuyContracts = 0;\n    let totSellContracts = 0;\n    let buyNum = 0;\n    let sellNum = 0;\n    let totBuyContractsMult = 0;\n    let totSellContractsMult = 0;\n    let realQty = 0;\n    let totCommission = 0;\n\n    for (let i = 0; i < inputData.length; i++) {\n      // realQty = inputData[i].orderQty - inputData[i].leavesQty;\n      if (inputData[i].side == \"Buy\" && inputData[i].leavesQty == 0) {\n        // totBuyPrice += parseFloat(inputData[i].price);\n        buyNum += 1;\n        totBuyContracts += inputData[i].orderQty;\n        totBuyContractsMult += inputData[i].orderQty * parseFloat(inputData[i].price);\n\n        if (inputData[0].orderQty == 40000) {\n          console.log(\"BUY SIDE\", inputData[i], realQty, totSellContracts, totBuyContracts, totSellContractsMult);\n        }\n      }\n\n      if (inputData[i].side == \"Sell\" && inputData[i].leavesQty == 0) {\n        sellNum += 1;\n\n        if (i == 0) {\n          let difference = inputData[i].orderQty + inputData[i].currentQty;\n          let newRealQty = inputData[i].orderQty - difference;\n          totSellContracts += newRealQty;\n          totSellContractsMult += newRealQty * parseFloat(inputData[i].price);\n        } else {\n          totSellContracts += inputData[i].orderQty;\n          totSellContractsMult += inputData[i].orderQty * parseFloat(inputData[i].price);\n        }\n\n        if (inputData[0].orderQty == 40000) {\n          console.log(\"SELL SIDE\", inputData[i], realQty, totSellContracts, totBuyContracts, totSellContractsMult);\n        }\n      }\n\n      if (inputData[i].orderType == \"Limit\" && inputData[i].execType !== \"Funding\") {\n        totCommission += realQty * 0.0025 / inputData[i].price;\n      }\n\n      if (inputData[i].orderType == \"Market\") {\n        totCommission -= realQty * 0.0075 / inputData[i].price;\n      }\n\n      if (inputData[i].orderType.includes(\"Stop\")) {\n        totCommission -= realQty * 0.0075 / inputData[i].price;\n      }\n\n      if (i == inputData.length - 1) {\n        let avgBuyPrice = totBuyContractsMult / totBuyContracts;\n        let avgSellPrice = totSellContractsMult / totSellContracts;\n        let pnl = (1 / avgBuyPrice - 1 / avgSellPrice) * totBuyContracts;\n\n        if (inputData[0].orderQty == 40000) {\n          console.log(pnl, avgBuyPrice, avgSellPrice, totBuyContracts);\n        }\n\n        let avgEntry;\n        let avgExit;\n\n        if (avgBuyPrice != null) {\n          avgExit = avgBuyPrice;\n        } else {\n          avgExit = 0;\n        }\n\n        if (avgSellPrice != null) {\n          avgEntry = avgSellPrice;\n        } else {\n          avgEntry = 0;\n        }\n\n        if (pnl != null) {\n          let myPnl = pnl + totCommission;\n          return new Promise(resolve => {\n            let end = {};\n            end[\"pnl\"] = myPnl;\n            end[\"avgEntryPrice\"] = avgEntry;\n            end[\"avgExitPrice\"] = avgExit;\n            end[\"cumQty\"] = totSellContracts;\n\n            if (inputData[0].orderQty == 40000) {\n              console.log(end);\n            }\n\n            resolve(end);\n          });\n        } else {\n          return new Promise(resolve => {\n            let end = {};\n            end[\"pnl\"] = 0;\n            end[\"avgEntryPrice\"] = avgEntry;\n            end[\"avgExitPrice\"] = avgExit;\n            end[\"cumQty\"] = totSellContracts;\n            resolve(end);\n          });\n        }\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/Users/manx/projects-2/bitsjournal/frontend/components/Dashboard/Tades/calcTrades.js"],"names":["calcTrades","inputData","side","execType","avgBuyPrice","avgSellPrice","totBuyContracts","totSellContracts","buyNum","sellNum","totBuyContractsMult","totSellContractsMult","realQty","totCommission","i","length","leavesQty","orderQty","parseFloat","price","orderType","includes","avgExit","avgEntry","thePnl","myPnl","Promise","resolve","end","console","log","difference","currentQty","newRealQty","pnl"],"mappings":"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","sourcesContent":["export async function calcTrades(inputData) {\n  // inputData = this.props.slic;\n  if (inputData[0].side == \"Buy\" && inputData[0].execType == \"Trade\") {\n    let avgBuyPrice = 0;\n    let avgSellPrice = 0;\n    let totBuyContracts = 0;\n    let totSellContracts = 0;\n    let buyNum = 0;\n    let sellNum = 0;\n    let totBuyContractsMult = 0;\n    let totSellContractsMult = 0;\n    let realQty = 0;\n    let totCommission = 0;\n    for (let i = 0; i < inputData.length; i++) {\n      // realQty = inputData[i].orderQty - inputData[i].leavesQty;\n      if (inputData[i].side == \"Buy\" && inputData[i].leavesQty == 0) {\n        buyNum += 1;\n        totBuyContracts += inputData[i].orderQty;\n        totBuyContractsMult +=\n          inputData[i].orderQty * parseFloat(inputData[i].price);\n      }\n      if (inputData[i].side == \"Sell\" && inputData[i].leavesQty == 0) {\n        sellNum += 1;\n        totSellContracts += inputData[i].orderQty;\n        totSellContractsMult +=\n          inputData[i].orderQty * parseFloat(inputData[i].price);\n      }\n      if (\n        inputData[i].orderType == \"Limit\" &&\n        inputData[i].execType !== \"Funding\"\n      ) {\n        totCommission += (realQty * 0.0025) / inputData[i].price;\n      }\n      if (inputData[i].orderType == \"Market\") {\n        totCommission -= (realQty * 0.0075) / inputData[i].price;\n      }\n      if (inputData[i].orderType.includes(\"Stop\")) {\n        totCommission -= (realQty * 0.0075) / inputData[i].price;\n      }\n      if (i == inputData.length - 1) {\n        avgBuyPrice = totBuyContractsMult / totBuyContracts;\n        avgSellPrice = totSellContractsMult / totSellContracts;\n        let avgExit;\n        let avgEntry;\n        if (avgBuyPrice != null) {\n          avgEntry = avgBuyPrice;\n        } else {\n          avgEntry = 0;\n        }\n        if (avgSellPrice != null) {\n          avgExit = avgSellPrice;\n        } else {\n          avgExit = 0;\n        }\n        // this.state.cumQty = totBuyContracts;\n        let thePnl = (1 / avgBuyPrice - 1 / avgSellPrice) * totSellContracts;\n        if (thePnl != null) {\n          let myPnl = thePnl + totCommission;\n          return new Promise((resolve) => {\n            let end = {};\n            end[\"pnl\"] = myPnl;\n            end[\"avgEntryPrice\"] = avgEntry;\n            end[\"avgExitPrice\"] = avgExit;\n            end[\"cumQty\"] = totBuyContracts;\n            resolve(end);\n          });\n          //   store.addPnl(myPnl);\n        } else {\n          return new Promise((resolve) => {\n            let end = {};\n            end[\"pnl\"] = 0;\n            end[\"avgEntryPrice\"] = avgEntry;\n            end[\"avgExitPrice\"] = avgExit;\n            end[\"cumQty\"] = totBuyContracts;\n            resolve(end);\n          });\n        }\n      }\n    }\n  }\n  if (inputData[0].side == \"Sell\" && inputData[0].execType == \"Trade\") {\n    let totBuyContracts = 0;\n    let totSellContracts = 0;\n    let buyNum = 0;\n    let sellNum = 0;\n    let totBuyContractsMult = 0;\n    let totSellContractsMult = 0;\n    let realQty = 0;\n    let totCommission = 0;\n    for (let i = 0; i < inputData.length; i++) {\n      // realQty = inputData[i].orderQty - inputData[i].leavesQty;\n      if (inputData[i].side == \"Buy\" && inputData[i].leavesQty == 0) {\n        // totBuyPrice += parseFloat(inputData[i].price);\n        buyNum += 1;\n        totBuyContracts += inputData[i].orderQty;\n        totBuyContractsMult +=\n          inputData[i].orderQty * parseFloat(inputData[i].price);\n        if (inputData[0].orderQty == 40000) {\n          console.log(\n            \"BUY SIDE\",\n            inputData[i],\n            realQty,\n            totSellContracts,\n            totBuyContracts,\n            totSellContractsMult\n          );\n        }\n      }\n      if (inputData[i].side == \"Sell\" && inputData[i].leavesQty == 0) {\n        sellNum += 1;\n        if (i == 0) {\n          let difference = inputData[i].orderQty + inputData[i].currentQty;\n          let newRealQty = inputData[i].orderQty - difference;\n          totSellContracts += newRealQty;\n          totSellContractsMult += newRealQty * parseFloat(inputData[i].price);\n        } else {\n          totSellContracts += inputData[i].orderQty;\n          totSellContractsMult +=\n            inputData[i].orderQty * parseFloat(inputData[i].price);\n        }\n        if (inputData[0].orderQty == 40000) {\n          console.log(\n            \"SELL SIDE\",\n            inputData[i],\n            realQty,\n            totSellContracts,\n            totBuyContracts,\n            totSellContractsMult\n          );\n        }\n      }\n      if (\n        inputData[i].orderType == \"Limit\" &&\n        inputData[i].execType !== \"Funding\"\n      ) {\n        totCommission += (realQty * 0.0025) / inputData[i].price;\n      }\n      if (inputData[i].orderType == \"Market\") {\n        totCommission -= (realQty * 0.0075) / inputData[i].price;\n      }\n      if (inputData[i].orderType.includes(\"Stop\")) {\n        totCommission -= (realQty * 0.0075) / inputData[i].price;\n      }\n      if (i == inputData.length - 1) {\n        let avgBuyPrice = totBuyContractsMult / totBuyContracts;\n        let avgSellPrice = totSellContractsMult / totSellContracts;\n        let pnl = (1 / avgBuyPrice - 1 / avgSellPrice) * totBuyContracts;\n        if (inputData[0].orderQty == 40000) {\n          console.log(pnl, avgBuyPrice, avgSellPrice, totBuyContracts);\n        }\n        let avgEntry;\n        let avgExit;\n        if (avgBuyPrice != null) {\n          avgExit = avgBuyPrice;\n        } else {\n          avgExit = 0;\n        }\n        if (avgSellPrice != null) {\n          avgEntry = avgSellPrice;\n        } else {\n          avgEntry = 0;\n        }\n\n        if (pnl != null) {\n          let myPnl = pnl + totCommission;\n          return new Promise((resolve) => {\n            let end = {};\n            end[\"pnl\"] = myPnl;\n            end[\"avgEntryPrice\"] = avgEntry;\n            end[\"avgExitPrice\"] = avgExit;\n            end[\"cumQty\"] = totSellContracts;\n            if (inputData[0].orderQty == 40000) {\n              console.log(end);\n            }\n            resolve(end);\n          });\n        } else {\n          return new Promise((resolve) => {\n            let end = {};\n            end[\"pnl\"] = 0;\n            end[\"avgEntryPrice\"] = avgEntry;\n            end[\"avgExitPrice\"] = avgExit;\n            end[\"cumQty\"] = totSellContracts;\n            resolve(end);\n          });\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}